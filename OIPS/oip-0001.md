---
oip: <to be assigned>
title: <Branded Token>
author: <Benjamin Bollen (@benjaminbollen)>
discussions-to: <discuss.openst.org>
status: Draft
type: <Standards Track>
category: <OpenST>
created: <2018-11-20>
---

<!--You can leave these HTML comments in your merged OIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new OIPs. Note that an OIP number will be assigned by an editor. When opening a pull request to submit your OIP, please use an abbreviated title in the filename, `OIP-draft_title_abbrev.md`. The title should be 44 characters or less. Thanks to the Ethereum Improvement Proposal (EIP) process for the model we borrow here.-->
# Branded Token

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the OIP.-->
A Branded Token allows a mainstream application to create a value-backed
utility token designed specifically for its application's context.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
Owners of a balance of a Branded Token (BT) must be able to redeem the underlying
value that is associated with the Branded Token. A Branded Token is only usable
within the application context. The application can maintain a policy on
accepting new BT holders (registered application users, KYC, etc.)

## Motivation
<!--The motivation is critical for OIPs that want to change the OpenST protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the OIP solves. OIP submissions without sufficient motivation may be rejected outright.-->

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature.-->

A Branded Token implements the required and optional
[EIP-20 Standard Token interface](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md).

A Branded Token (BT) can be organised[OIP-<Organized>] such that accepting a stake
request to mint more Branded Tokens backed by OST can be controlled
by the Organisation such that the total supply is determinable.

### Stake Request

A staker can call `requestStake` to mint more branded tokens by staking
a value token (OST) to fully back the BT.  The BT can be staked at constant
conversion rate BT:OST, or can be staked against a basket of value tokens.

```solidity
interface ValueBacked {
    function requestStake(
        uint256 _amount,
        uint256 _expectedAmount
    )
        returns (bytes32 stakeRequestHash_);

    function acceptStakeRequest(
        bytes32 _stakeRequestHash,
        bytes32 _r,
        bytes32 _s,
        uint8 _v
    )
        returns (bool success_);

    function revokeStakeRequest()
        returns (bool success_);
}
```

```solidity
//keccak256(
//    "EIP712Domain(address brandedTokenContract)"
//);
bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x

//keccak256(
//    "StakeRequest(address staker,uint256 amount,uint256 nonce)"
//);
bytes32 public constant BT_STAKE_REQUEST_TYPEHASH = 0x

struct StakeRequest {
    address staker,
    uint256 amount, // value backed in OST
    uint256 nonce
}
```

### Redeem

```solidity

```

### An Internal Economy 
It should be possible to restrict the use of an application's utility token
to the application context.  To this end we require the recipient `_to`
in calls to `transfer` and `transferFrom` is registered as an _internal actor_.

Addresses can be registered as internal actors, and once an actor has been
registered as internal it MUST remain registered.

```solidity
interface Internal {
    function registerInternalActors(
        address[] _internalActors) external returns (bool success);
    function isInternalActor(
        address _actor) external view returns (bool isInternal);
}
```

```solidity
require(isInternalActor(_to),
    "Tokens can only be transfered to internal actors.");
```

### Restricting use on Ethereum mainnet

Because Ethereum mainnet cannot support the transaction volume of any
mainstream application, we want the value definition of the Branded Token
to be declared on Ethereum mainnet, but restrict its direct use.

We therefore introduce the `Restricted` interface such that users can own
a balance of the Branded Token on Ethereum mainnet, however, by default they
cannot call `transfer` or `transferFrom`.  Users can always `redeem` their
balance for the underlying value token.

The restriction SHOULD be lifted for contracts that facilitate layer-2 scaling
of the application (i.e. Mosaic gateway contracts, payment channels,
zkSTARK contracts).  These contracts can move a user's token balance into
the scaling solution and give the user access within the internal economy
to her Branded Tokens.

When the user exits the scaling solution contract,
the user has a balance which she can redeem or re-enter into a (different)
scaling contract.

```solidity
interface Restricted {
    function liftRestriction(
        address[] _restrictionLifted) external returns (bool success);
    function isUnrestricted(
        address _actor) external view returns (bool isUnrestricted);
}
```

```solidity
modifier hasRestrictionLifted {
    require(
        canTransfer[msg.sender],
        "Msg.sender is not a transferor."
    );
    _;
}
```


## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->

The property _internal_ for a token restricts the creation of a secondary market
of the token while allowing open transactions within the context of the
intended application.  Any user can always `redeem` a token balance to exit
the internal economy and recover value token that backed the branded token,
which can be freely transfered.

## Test Cases
<!--Test cases for an implementation are mandatory for OIPs that are affecting consensus changes. Other OIPs can choose to include links to test cases if applicable.-->

## Implementation
<!--The implementations must be completed before any OIP is given status "Final", but it need not be completed before the OIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->
